package days04;

/**
 * @author Yelin
 * @date 2022. 2. 18. - 오전 11:35:57
 * @subject 연산자(operator) p86 中 2) 비트논리 연산자 : ~  &  ^  | p115
 * @content 
 * 			비트연산자는 비트 값을 가지고 논리연산자를 취하는 것
 * 			~ 틸드 연산자(비트 부정 연산자)
 *          & 비트 논리 AND 연산자
 *          ^ XOR 연산자 > eXclusiveOR 연산자 > 배타적인 == 서로 다르다 > 서로 다를 때 참(true)인 연산자
 *          | 비트 논리 OR 연산자
 * 			
 */

public class Ex02 {

	public static void main(String[] args) {
		
		int i = 10;
		
		// 1. ~ 틸드 연산자(비트 부정 연산자)
		System.out.println(~i);  // 결과 : -11
		
		// 비트 연산자이기 때문에 10 ->  0000 1010(2진수)
		//                       ~10 -> ~0000 1010(2진수) > 각각의 비트 값을 부정하겠다.
		//                               1111 0101  == -11
		
		// 틸드는 음수 표현 방법 순서를 반대로 하면 된다.
		// 4) -1        1111 0100
		// 3) 1의 보수  0000 1011
		// 1)               -11
		
		// 음수 표현 방법(2의 보수법)
		// -11
		// 1) 절대치            11
		// 2) 2진수로 변환      0000 1011
		// 3) 1의 보수 취하기   1111 0100
		// 4) +1 0000 0001      1111 0101
		
		//2 . & 비트 논리 AND 연산자  > 비트 값을 가지고 AND 연산을 하겠다
		System.out.println(10 & 3);
		// 10		0000 1010
		//  3		0000 0011
		//  &       0000 0010
		// 결과값 :         2
		
		// 3. ^ XOR연산자 > 서로 다를 때 참인 연산자
		System.out.println(10 ^ 3);
		// 10		0000 1010
		//  3		0000 0011
		//  ^       0000 1001    > 8 + 1
		// 결과값 :         9
		
		// 4. | 비트 논리 OR 연산자 > 두 개 중에 하나라도 1이면 1
		System.out.println(10 ^ 3);
		// 10		0000 1010
		//  3		0000 0011
		//  |       0000 1011    > 8 + 2 + 1
		// 결과값 :        11
		

	}

}
